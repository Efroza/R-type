\hypertarget{client_2src_2udp_8cpp}{}\doxysection{client/src/udp.cpp File Reference}
\label{client_2src_2udp_8cpp}\index{client/src/udp.cpp@{client/src/udp.cpp}}
{\ttfamily \#include \char`\"{}../include/client.\+hpp\char`\"{}}\newline
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{client_2src_2udp_8cpp_a46e1dc7ee76f4561887118c5fff17aad}{send\+\_\+struct\+\_\+client\+\_\+udp}} (udp\+::socket \&socket, udp\+::endpoint \&server\+\_\+endpoint, std\+::string input)
\item 
void \mbox{\hyperlink{client_2src_2udp_8cpp_ad2385b067be92e91bc85293e79c71da6}{send\+\_\+data\+\_\+client\+\_\+udp}} (udp\+::socket \&socket, udp\+::endpoint \&server\+\_\+endpoint)
\begin{DoxyCompactList}\small\item\em Loop to send data to the server. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{client_2src_2udp_8cpp_aec9e0b7a3008e3d2b56cd39cabcf4a25}{receive\+\_\+data\+\_\+client\+\_\+udp}} (Header header, udp\+::socket \&socket, udp\+::endpoint \&sender\+\_\+endpoint, asio\+::error\+\_\+code \&ec)
\begin{DoxyCompactList}\small\item\em This function will translate the data received from the server into a struct. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{client_2src_2udp_8cpp_a243d014db993350d43bc69d3f9d52719}{receive\+\_\+thread\+\_\+client\+\_\+udp}} (udp\+::socket \&socket, asio\+::io\+\_\+context \&io\+\_\+context)
\begin{DoxyCompactList}\small\item\em Loop to receive data from the server. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{client_2src_2udp_8cpp_a49ce0f9ae838decb9091026c0712b3ee}{async\+\_\+udp\+\_\+client}} (const std\+::string \&host, const std\+::string \&port)
\begin{DoxyCompactList}\small\item\em Launch a UDP client. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{client_2src_2udp_8cpp_a49ce0f9ae838decb9091026c0712b3ee}\label{client_2src_2udp_8cpp_a49ce0f9ae838decb9091026c0712b3ee}} 
\index{udp.cpp@{udp.cpp}!async\_udp\_client@{async\_udp\_client}}
\index{async\_udp\_client@{async\_udp\_client}!udp.cpp@{udp.cpp}}
\doxysubsubsection{\texorpdfstring{async\_udp\_client()}{async\_udp\_client()}}
{\footnotesize\ttfamily void async\+\_\+udp\+\_\+client (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{host,  }\item[{const std\+::string \&}]{port }\end{DoxyParamCaption})}



Launch a UDP client. 


\begin{DoxyParams}{Parameters}
{\em host} & represents the host of the server. \\
\hline
{\em port} & represents the port of the server. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{client_2src_2udp_8cpp_a243d014db993350d43bc69d3f9d52719}{receive\+\_\+thread\+\_\+client\+\_\+udp(udp\+::socket\& socket, asio\+::io\+\_\+context\& io\+\_\+context)}} 

\mbox{\hyperlink{client_2src_2udp_8cpp_ad2385b067be92e91bc85293e79c71da6}{send\+\_\+data\+\_\+client\+\_\+udp(udp\+::socket\& socket, udp\+::endpoint\& server\+\_\+endpoint)}}
\end{DoxySeeAlso}
This function will launch a UDP client.

It will create a thread to receive data from the server and a there is a call to send\+\_\+data\+\_\+client\+\_\+udp to send data to the server. \mbox{\Hypertarget{client_2src_2udp_8cpp_aec9e0b7a3008e3d2b56cd39cabcf4a25}\label{client_2src_2udp_8cpp_aec9e0b7a3008e3d2b56cd39cabcf4a25}} 
\index{udp.cpp@{udp.cpp}!receive\_data\_client\_udp@{receive\_data\_client\_udp}}
\index{receive\_data\_client\_udp@{receive\_data\_client\_udp}!udp.cpp@{udp.cpp}}
\doxysubsubsection{\texorpdfstring{receive\_data\_client\_udp()}{receive\_data\_client\_udp()}}
{\footnotesize\ttfamily void receive\+\_\+data\+\_\+client\+\_\+udp (\begin{DoxyParamCaption}\item[{Header}]{header,  }\item[{udp\+::socket \&}]{socket,  }\item[{udp\+::endpoint \&}]{sender\+\_\+endpoint,  }\item[{asio\+::error\+\_\+code \&}]{ec }\end{DoxyParamCaption})}



This function will translate the data received from the server into a struct. 


\begin{DoxyParams}{Parameters}
{\em header} & represents the header of the data received. \\
\hline
{\em socket} & represents the socket of the client. \\
\hline
{\em sender\+\_\+endpoint} & represents the endpoint of the server. \\
\hline
{\em ec} & represents the error code. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void
\end{DoxyReturn}
This function will read the data received from the server.

It creates two struct one if it is a position and another one if it is a message.

Depending of the data type it will print the data. \mbox{\Hypertarget{client_2src_2udp_8cpp_a243d014db993350d43bc69d3f9d52719}\label{client_2src_2udp_8cpp_a243d014db993350d43bc69d3f9d52719}} 
\index{udp.cpp@{udp.cpp}!receive\_thread\_client\_udp@{receive\_thread\_client\_udp}}
\index{receive\_thread\_client\_udp@{receive\_thread\_client\_udp}!udp.cpp@{udp.cpp}}
\doxysubsubsection{\texorpdfstring{receive\_thread\_client\_udp()}{receive\_thread\_client\_udp()}}
{\footnotesize\ttfamily void receive\+\_\+thread\+\_\+client\+\_\+udp (\begin{DoxyParamCaption}\item[{udp\+::socket \&}]{socket,  }\item[{asio\+::io\+\_\+context \&}]{io\+\_\+context }\end{DoxyParamCaption})}



Loop to receive data from the server. 


\begin{DoxyParams}{Parameters}
{\em socket} & represents the socket of the client. \\
\hline
{\em io\+\_\+context} & represents the io\+\_\+context of the client. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{client_2src_2udp_8cpp_aec9e0b7a3008e3d2b56cd39cabcf4a25}{receive\+\_\+data\+\_\+client\+\_\+udp(\+Header header, udp\+::socket\& socket, udp\+::endpoint\& sender\+\_\+endpoint, asio\+::error\+\_\+code\& ec)}}
\end{DoxySeeAlso}
This function will loop to receive data from the server.

It will call receive\+\_\+data\+\_\+client\+\_\+udp to receive data from the server.

It will receive data from the server until the server is closed. \mbox{\Hypertarget{client_2src_2udp_8cpp_ad2385b067be92e91bc85293e79c71da6}\label{client_2src_2udp_8cpp_ad2385b067be92e91bc85293e79c71da6}} 
\index{udp.cpp@{udp.cpp}!send\_data\_client\_udp@{send\_data\_client\_udp}}
\index{send\_data\_client\_udp@{send\_data\_client\_udp}!udp.cpp@{udp.cpp}}
\doxysubsubsection{\texorpdfstring{send\_data\_client\_udp()}{send\_data\_client\_udp()}}
{\footnotesize\ttfamily void send\+\_\+data\+\_\+client\+\_\+udp (\begin{DoxyParamCaption}\item[{udp\+::socket \&}]{socket,  }\item[{udp\+::endpoint \&}]{server\+\_\+endpoint }\end{DoxyParamCaption})}



Loop to send data to the server. 


\begin{DoxyParams}{Parameters}
{\em socket} & represents the socket of the client. \\
\hline
{\em server\+\_\+endpoint} & represents the endpoint of the server. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{client_2src_2udp_8cpp_a46e1dc7ee76f4561887118c5fff17aad}{send\+\_\+struct\+\_\+client\+\_\+udp(udp\+::socket\& socket, udp\+::endpoint\& server\+\_\+endpoint, std\+::string input)}}
\end{DoxySeeAlso}
This function will loop to send data to the server.

It will call send\+\_\+struct\+\_\+client\+\_\+udp to send data to the server.

It will send data to the server until the server is closed. \mbox{\Hypertarget{client_2src_2udp_8cpp_a46e1dc7ee76f4561887118c5fff17aad}\label{client_2src_2udp_8cpp_a46e1dc7ee76f4561887118c5fff17aad}} 
\index{udp.cpp@{udp.cpp}!send\_struct\_client\_udp@{send\_struct\_client\_udp}}
\index{send\_struct\_client\_udp@{send\_struct\_client\_udp}!udp.cpp@{udp.cpp}}
\doxysubsubsection{\texorpdfstring{send\_struct\_client\_udp()}{send\_struct\_client\_udp()}}
{\footnotesize\ttfamily void send\+\_\+struct\+\_\+client\+\_\+udp (\begin{DoxyParamCaption}\item[{udp\+::socket \&}]{socket,  }\item[{udp\+::endpoint \&}]{server\+\_\+endpoint,  }\item[{std\+::string}]{input }\end{DoxyParamCaption})}

This function will send data to the server. 
\begin{DoxyParams}{Parameters}
{\em socket} & represents the socket of the client. \\
\hline
{\em server\+\_\+endpoint} & represents the endpoint of the server. \\
\hline
{\em input} & represents the input of the user. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void
\end{DoxyReturn}
This function will send a certain stuct to the server depending of the message.

It will create a header with a data type depending of the message.

If the message contains a comma, it will send a position. If not, it will send a message.

It will send the header and the struct to the server. 